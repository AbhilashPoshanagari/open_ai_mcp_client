import{i as h,pg as l}from"./chunk-PR3HXOEE.js";function y(o,t){let e=new Set;for(let i of t)o.has(i)&&e.add(i);return e}function m(o,t){let e=new Set(o);for(let i of t)e.add(i);return e}function c(o,t){let e=new Set(o);for(let i of t)e.delete(i);return e}function p(o){return Array.from(o).map(t=>`"${t}"`).join(", ")}var _=class w extends l{static lc_name(){return"SequentialChain"}chains;inputVariables;outputVariables;returnAll;get inputKeys(){return this.inputVariables}get outputKeys(){return this.outputVariables}constructor(t){if(super(t),this.chains=t.chains,this.inputVariables=t.inputVariables,this.outputVariables=t.outputVariables??[],this.outputVariables.length>0&&t.returnAll)throw new Error("Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.");this.returnAll=t.returnAll??!1,this._validateChains()}_validateChains(){if(this.chains.length===0)throw new Error("Sequential chain must have at least one chain.");let t=this.memory?.memoryKeys??[],e=new Set(this.inputKeys),i=new Set(t),a=y(e,i);if(a.size>0)throw new Error(`The following keys: ${p(a)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);let n=m(e,i);for(let s of this.chains){let r=c(new Set(s.inputKeys),n);if(s.memory&&(r=c(r,new Set(s.memory.memoryKeys))),r.size>0)throw new Error(`Missing variables for chain "${s._chainType()}": ${p(r)}. Only got the following variables: ${p(n)}.`);let u=new Set(s.outputKeys),f=y(n,u);if(f.size>0)throw new Error(`The following output variables for chain "${s._chainType()}" are overlapping: ${p(f)}. This can lead to unexpected behaviour.`);for(let d of u)n.add(d)}if(this.outputVariables.length===0)if(this.returnAll){let s=c(n,e);this.outputVariables=Array.from(s)}else this.outputVariables=this.chains[this.chains.length-1].outputKeys;else{let s=c(new Set(this.outputVariables),new Set(n));if(s.size>0)throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${p(s)}.`)}}_call(t,e){return h(this,null,function*(){let i={},a=t,n=0;for(let r of this.chains){n+=1,i=yield r.call(a,e?.getChild(`step_${n}`));for(let u of Object.keys(i))a[u]=i[u]}let s={};for(let r of this.outputVariables)s[r]=a[r];return s})}_chainType(){return"sequential_chain"}static deserialize(t){return h(this,null,function*(){let e=[],i=t.input_variables,a=t.output_variables,n=t.chains;for(let s of n){let r=yield l.deserialize(s);e.push(r)}return new w({chains:e,inputVariables:i,outputVariables:a})})}serialize(){let t=[];for(let e of this.chains)t.push(e.serialize());return{_type:this._chainType(),input_variables:this.inputVariables,output_variables:this.outputVariables,chains:t}}},v=class b extends l{static lc_name(){return"SimpleSequentialChain"}chains;inputKey="input";outputKey="output";trimOutputs;get inputKeys(){return[this.inputKey]}get outputKeys(){return[this.outputKey]}constructor(t){super(t),this.chains=t.chains,this.trimOutputs=t.trimOutputs??!1,this._validateChains()}_validateChains(){for(let t of this.chains){if(t.inputKeys.filter(e=>!t.memory?.memoryKeys.includes(e)).length!==1)throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${t.inputKeys.length} for ${t._chainType()}.`);if(t.outputKeys.length!==1)throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${t.outputKeys.length} for ${t._chainType()}.`)}}_call(t,e){return h(this,null,function*(){let i=t[this.inputKey],a=0;for(let n of this.chains)a+=1,i=(yield n.call({[n.inputKeys[0]]:i,signal:t.signal},e?.getChild(`step_${a}`)))[n.outputKeys[0]],this.trimOutputs&&(i=i.trim()),yield e?.handleText(i);return{[this.outputKey]:i}})}_chainType(){return"simple_sequential_chain"}static deserialize(t){return h(this,null,function*(){let e=[],i=t.chains;for(let a of i){let n=yield l.deserialize(a);e.push(n)}return new b({chains:e})})}serialize(){let t=[];for(let e of this.chains)t.push(e.serialize());return{_type:this._chainType(),chains:t}}};export{_ as SequentialChain,v as SimpleSequentialChain};
